# Synchronous API
In Camunda 7, it is possible to execute part of a process in a synchronous manner.

# Use Case

## Create a Process Instance
When creating a process instance, it may be necessary to execute two activities sequentially, while keeping the API request blocked. Once these tasks complete, the API unblocks and returns a response, including variables generated by those tasks.

Example: University Application
In a university admission scenario:

The first task retrieves the applicant‚Äôs GPA.

The second task applies decision rules and generates a result: Accepted, Rejected, or On Hold.

This allows the application to synchronously return a decision status to the applicant right after the instance is created.

## Execute a User Task
This pattern can also be applied after a user task.

Example: Application Review
A reviewer determines whether to proceed with the application. If the decision is to accept:

A task checks whether the student is still on the waiting list.

The system immediately provides the result, allowing the reviewer to make an informed, real-time decision.

## Publish a Message
Sometimes, a message is sent to a running process, and the application expects an immediate response.

Example: Status Inquiry
A message is published to query the process, and it synchronously returns information, such as the current decision state.

## Implementing This in Camunda 8
The goal is to replicate this synchronous behavior in Camunda 8, enabling a smooth migration from Camunda 7.

In Camunda 8, all task workers operate asynchronously ‚Äî meaning the API call returns immediately after sending a command.

##  üîç Challenge
How can we implement a mechanism that:

* Starts a process or sends a message

* Waits (blocks) until the process reaches a specific point (e.g. task completion)

* Returns relevant data synchronously to the caller?

This challenge must be solved to bring synchronous workflows into a fundamentally asynchronous engine like Camunda 8.

