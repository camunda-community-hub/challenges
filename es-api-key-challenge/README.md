# Challenge: Elasticsearch API Key Authentication via Custom Header Plugin (Camunda 8)## PurposeThis challenge documents a **non-standard but extensible approach** to connect **Camunda 8 (8.7 / 8.8)** to an **external Elasticsearch cluster using API key authentication**, instead of basic authentication (username/password).It is intended to:- Share guidance internally with colleagues- Provide a reference or starting point for customers with strict security requirements- Demonstrate how Camunda‚Äôs **custom Elasticsearch header plugin mechanism** can be leveraged> ‚ö†Ô∏è **Important**: This approach is **not officially supported out-of-the-box** by Camunda 8. It should be treated as a **custom extension / proof of concept**. Only previous version to Camunda 8.7 is tested, Camunda 8.8's solution is theory draft.---## Background & Context### The Problem- The customer runs **Camunda 8.6 / 8.7** with an **external Elasticsearch**- Their security policy **does not allow basic authentication**- Elasticsearch is secured using **API key authentication** (`APIKEY_ID:APIKEY_VALUE`, Base64-encoded)### Key LimitationAs of Camunda 8.7:- ‚úÖ **Basic authentication** to Elasticsearch is supported- ‚ùå **Native API key authentication** is **not supported**- ‚ùå No Helm or values.yaml option exists to configure API key auth directly---## Supported vs Unsupported Paths### Supported (Out-of-the-Box)- Store Elasticsearch username/password in a Kubernetes Secret- Configure:    - `global.elasticsearch.auth.username`    - `global.elasticsearch.auth.password`### Unsupported / Custom (This Challenge)- Use **API key authentication** via:    - Custom Java plugin    - Custom HTTP headers (`Authorization: ApiKey <base64>`)    - Manual Helm wiringThis challenge focuses exclusively on the **custom plugin approach**.---## High-Level SolutionCamunda 8.6+ introduces a **custom header plugin mechanism** that allows components to inject HTTP headers into Elasticsearch requests.### Strategy1. Implement `DatabaseCustomHeaderSupplier`2. Read the Base64 API key from an environment variable3. Inject the `Authorization: ApiKey <base64>` header4. Package the implementation as a JAR5. Mount the JAR into Camunda components6. Register the plugin via environment variables---## Architecture Overview```text+-------------------+| Camunda Component || (Zeebe / Operate) |+---------+---------+          |          |  HTTP Requests          |  Authorization: ApiKey <base64>          v+-------------------+|  Elasticsearch    ||  (External)       |+-------------------+```---## Prerequisites- Camunda 8.6 or 8.7- External Elasticsearch (7.x / 8.x)- Java 17+- Maven- Kubernetes- Helm-based Camunda deployment---## Custom Header Plugin Implementation### InterfaceCamunda exposes the following interface:```javaDatabaseCustomHeaderSupplier```This interface is called whenever a request to Elasticsearch is made.---### Example Plugin Implementation```javapackage com.myplugin;import io.camunda.plugin.search.header.CustomHeader;import io.camunda.plugin.search.header.DatabaseCustomHeaderSupplier;import java.util.UUID;public class MyCustomHeaderPlugin implements DatabaseCustomHeaderSupplier {    public static final String CUSTOM_TOKEN_PLUGIN = "X-Custom-Auth-Token";    @Override    public CustomHeader getSearchDatabaseCustomHeader() {        return new CustomHeader(CUSTOM_TOKEN_PLUGIN, UUID.randomUUID().toString());    }}```---## Packaging the Plugin- Build the plugin as a **JAR**- Example output:```textes-api-key-header-plugin.jar```---## Kubernetes & Helm Integration### Step 1: Create the API Key Secret```bashkubectl create secret generic es-api-key \  --from-literal=ES_API_KEY_B64=<base64_api_key>```---### Step 2: Create a Secret for the Plugin JAR```bashkubectl create secret generic es-api-key-plugin-jar \  --from-file=es-api-key-header-plugin.jar```---## Registering the Plugin (Per Component)Each Camunda component must be configured **independently**.### Operate```yamloperate:  extraVolumes:    - name: es-api-plugin      secret:        secretName: es-api-key-plugin-jar  extraVolumeMounts:    - name: es-api-plugin      mountPath: /usr/local/plugins/es-api-key-plugin.jar      subPath: es-api-key-plugin.jar  env:    - name: CAMUNDA_OPERATE_ELASTICSEARCH_INTERCEPTORPLUGINS_0_ID      value: es-api-plugin    - name: CAMUNDA_OPERATE_ELASTICSEARCH_INTERCEPTORPLUGINS_0_CLASSNAME      value: com.example.camunda.es.EsApiKeyHeaderPlugin    - name: CAMUNDA_OPERATE_ELASTICSEARCH_INTERCEPTORPLUGINS_0_JARPATH      value: /usr/local/plugins/es-api-key-plugin.jar```### Tasklist```yamltasklist:  extraVolumes:    - name: es-api-plugin      secret:        secretName: es-api-key-plugin-jar  extraVolumeMounts:    - name: es-api-plugin      mountPath: /usr/local/plugins/es-api-key-plugin.jar      subPath: es-api-key-plugin.jar    env:    - name: CAMUNDA_TASKLIST_ELASTICSEARCH_INTERCEPTORPLUGINS_0_ID      value: es-api-plugin    - name: CAMUNDA_TASKLIST_ELASTICSEARCH_INTERCEPTORPLUGINS_0_CLASSNAME      value: com.example.camunda.es.EsApiKeyHeaderPlugin    - name: CAMUNDA_TASKLIST_ELASTICSEARCH_INTERCEPTORPLUGINS_0_JARPATH      value: /usr/local/plugins/es-api-key-plugin.jar```### Optimize```yamloptimize:  extraVolumes:    - name: es-api-plugin      secret:        secretName: es-api-key-plugin-jar  extraVolumeMounts:    - name: es-api-plugin      mountPath: /usr/local/plugins/es-api-key-plugin.jar      subPath: es-api-key-plugin.jar  env:    - name: CAMUNDA_OPTIMIZE_ELASTICSEARCH_INTERCEPTORPLUGINS_0_ID      value: es-api-key    - name: CAMUNDA_OPTIMIZE_ELASTICSEARCH_INTERCEPTORPLUGINS_0_CLASSNAME      value: com.example.camunda.optimize.es.ElasticApiKeyHeaderPlugin    - name: CAMUNDA_OPTIMIZE_ELASTICSEARCH_INTERCEPTORPLUGINS_0_JARPATH      value: /optimize/plugins/es-api-key-plugin.jar```### Zeebe ```yamlzeebe:  extraVolumes:    - name: es-api-plugin      secret:        secretName: es-api-key-plugin-jar  extraVolumeMounts:    - name: es-api-plugin      mountPath: /usr/local/plugins/es-api-key-plugin.jar      subPath: es-api-key-plugin.jar  env:    - name: ZEEBE_ELASTICSEARCH_INTERCEPTORPLUGINS_0_ID      value: es-api-key    - name: ZEEBE_ELASTICSEARCH_INTERCEPTORPLUGINS_0_CLASSNAME      value: com.example.ElasticApiKeyHeaderPlugin    - name: ZEEBE_ELASTICSEARCH_INTERCEPTORPLUGINS_0_JARPATH      value: /usr/local/plugins/es-api-key-plugin.jar```---## Key Takeaways- Camunda 8 do **not** support Elasticsearch API key auth natively- Custom header plugins provide a **possible workaround**- This approach is **custom, unsupported, and requires testing**- Best suited for **Consulting-led implementations**---## Challenge: Toward a More Production-Ready SetupFor a more **robust and production-ready configuration**, it is recommended to use an **init container** to manage the custom plugin lifecycle rather than relying solely on `extraVolumes` mounted directly from Secrets.### Why an initContainer?Using an init container provides several advantages:- Clear separation of responsibilities (bootstrap vs runtime)- Reduced exposure of the plugin JAR to the main container- Flexibility to:    - Download the JAR from a GitHub release    - Validate checksums    - Switch plugin versions without rebuilding images- Easier promotion across environments (dev ‚Üí test ‚Üí prod)This pattern is closer to how teams typically manage **custom extensions in production Kubernetes environments**.---## Sample initContainer-Based Configuration The following example theory draft for **Camunda 8.8** shows how the Elasticsearch API key plugin can be staged via an init container and shared with Camunda components using an `emptyDir` volume.```yamlorchestration:  # Shared volume where the initContainer drops the plugin JAR  extraVolumes:    - name: es-api-plugin      emptyDir: {}  # Mount the populated JAR into the main orchestration container  extraVolumeMounts:    - name: es-api-plugin      mountPath: /usr/local/plugins/es-api-key-plugin.jar      subPath: es-api-key-plugin.jar  # Init container: prepares the plugin JAR  initContainers:    - name: init-es-api-plugin      image: busybox:1.36      imagePullPolicy: IfNotPresent      command: ["/bin/sh", "-c"]      args:        - |          # Example uses a Secret; can be replaced with curl/wget          cp /plugin-src/es-api-key-plugin.jar /plugins/es-api-key-plugin.jar      volumeMounts:        # Secret containing the JAR (only visible to init container)        - name: es-api-plugin-secret          mountPath: /plugin-src        # Shared volume handed off to main container        - name: es-api-plugin          mountPath: /plugins  # Extra volume only needed by the initContainer  extraVolumesAppend:    - name: es-api-plugin-secret      secret:        secretName: es-api-key-plugin-jar  env:    # Operate importer ‚Üí Zeebe Elasticsearch    - name: CAMUNDA_OPERATE_ZEEBEELASTICSEARCH_INTERCEPTORPLUGINS_0_ID      value: es-api-key    - name: CAMUNDA_OPERATE_ZEEBEELASTICSEARCH_INTERCEPTORPLUGINS_0_CLASSNAME      value: com.example.camunda.es.EsApiKeyHeaderPlugin    - name: CAMUNDA_OPERATE_ZEEBEELASTICSEARCH_INTERCEPTORPLUGINS_0_JARPATH      value: /usr/local/plugins/es-api-key-plugin.jar    # Operate ‚Üí Elasticsearch client    - name: CAMUNDA_OPERATE_ELASTICSEARCH_INTERCEPTORPLUGINS_0_ID      value: es-api-key    - name: CAMUNDA_OPERATE_ELASTICSEARCH_INTERCEPTORPLUGINS_0_CLASSNAME      value: com.example.camunda.es.EsApiKeyHeaderPlugin    - name: CAMUNDA_OPERATE_ELASTICSEARCH_INTERCEPTORPLUGINS_0_JARPATH      value: /usr/local/plugins/es-api-key-plugin.jar    # Tasklist importer ‚Üí Zeebe Elasticsearch    - name: CAMUNDA_TASKLIST_ZEEBEELASTICSEARCH_INTERCEPTORPLUGINS_0_ID      value: es-api-key    - name: CAMUNDA_TASKLIST_ZEEBEELASTICSEARCH_INTERCEPTORPLUGINS_0_CLASSNAME      value: com.example.camunda.es.EsApiKeyHeaderPlugin    - name: CAMUNDA_TASKLIST_ZEEBEELASTICSEARCH_INTERCEPTORPLUGINS_0_JARPATH      value: /usr/local/plugins/es-api-key-plugin.jar    # Tasklist ‚Üí Elasticsearch client    - name: CAMUNDA_TASKLIST_ELASTICSEARCH_INTERCEPTORPLUGINS_0_ID      value: es-api-key    - name: CAMUNDA_TASKLIST_ELASTICSEARCH_INTERCEPTORPLUGINS_0_CLASSNAME      value: com.example.camunda.es.EsApiKeyHeaderPlugin    - name: CAMUNDA_TASKLIST_ELASTICSEARCH_INTERCEPTORPLUGINS_0_JARPATH      value: /usr/local/plugins/es-api-key-plugin.jar    # Elasticsearch API key    - name: ES_API_KEY_B64      valueFrom:        secretKeyRef:          name: es-api-key          key: ES_API_KEY_B64```### Notes- The `cp` command can be replaced with `curl` or `wget` to download from a GitHub release- Only the init container needs access to the Secret containing the JAR- The main container only sees the final filesystem artifact- For more flexibility, use download jar from GitHub (Theory draft for Camunda 8.8: [orchestration_8.8_init_containter_download.yaml](solution/camunda_8_8_solution/orchestration_8_8_init_containter_download.yaml))---This pattern is recommended when treating the custom header plugin as a **long-lived, environment-managed extension** rather than a short-lived proof of concept.---### üìö Resources* [**Configure custom HTTP headers for database clients**](https://docs.camunda.io/docs/self-managed/deployment/helm/configure/database/configure-db-custom-headers/)